use crate::lexer::{Token, LexicalError};
use crate::ast;
use rust_decimal::Decimal;

grammar<'input>;

pub Tree: ast::Node = {
    Expression
}

Expression: ast::Node = {
    #[precedence(level="2")] #[assoc(side="left")]
    <left:Expression> "and" <right:Expression> => {
        ast::Node::And(Box::new(left), Box::new(right))
    },
    #[precedence(level="2")] #[assoc(side="left")]
    <left:Expression> "or" <right:Expression> => {
        ast::Node::Or(Box::new(left), Box::new(right))
    },
    #[precedence(level="1")]
    "(" <expression:Expression> ")" => expression,
    NumericExpression,
    #[precedence(level="1")]
    EqualityExpression,
    #[precedence(level="1")]
    NullExpression,
    #[precedence(level="1")]
    ListExpression,
    #[precedence(level="1")]
    SetExpression,
    #[precedence(level="1")]
    "not" <expression:Expression> => ast::Node::Not(Box::new(expression)),
    #[precedence(level="0")]
    <variable:"identifier"> => ast::Node::Value(ast::Predicate {
        attribute: variable.to_string(),
        kind: ast::PredicateKind::Variable,
    }),
}

NumericExpression: ast::Node = {
    <left:"identifier"> "<" <right:NumericValue> => {
        ast::Node::Value(ast::Predicate {
            attribute: left.to_string(),
            kind: ast::PredicateKind::Comparison(ast::ComparisonOperator::LessThan, right)
        })
    },
    <left:"identifier"> "<=" <right:NumericValue> => {
        ast::Node::Value(ast::Predicate {
            attribute: left.to_string(),
            kind: ast::PredicateKind::Comparison(ast::ComparisonOperator::LessThanEqual, right)
        })
    },
    <left:"identifier"> ">" <right:NumericValue> => {
        ast::Node::Value(ast::Predicate {
            attribute: left.to_string(),
            kind: ast::PredicateKind::Comparison(ast::ComparisonOperator::GreaterThan, right)
        })
    },
    <left:"identifier"> ">=" <right:NumericValue> => {
        ast::Node::Value(ast::Predicate {
            attribute: left.to_string(),
            kind: ast::PredicateKind::Comparison(ast::ComparisonOperator::GreaterThanEqual, right)
        })
    },
    <left:NumericValue> "<" <right:"identifier"> => {
        ast::Node::Value(ast::Predicate {
            attribute: right.to_string(),
            kind: ast::PredicateKind::Comparison(ast::ComparisonOperator::GreaterThan, left)
        })
    },
    <left:NumericValue> "<=" <right:"identifier"> => {
        ast::Node::Value(ast::Predicate {
            attribute: right.to_string(),
            kind: ast::PredicateKind::Comparison(ast::ComparisonOperator::GreaterThanEqual, left)
        })
    },
    <left:NumericValue> ">" <right:"identifier"> => {
        ast::Node::Value(ast::Predicate {
            attribute: right.to_string(),
            kind: ast::PredicateKind::Comparison(ast::ComparisonOperator::LessThan, left)
        })
    },
    <left:NumericValue> ">=" <right:"identifier"> => {
        ast::Node::Value(ast::Predicate {
            attribute: right.to_string(),
            kind: ast::PredicateKind::Comparison(ast::ComparisonOperator::LessThanEqual, left)
        })
    },
}

NumericValue: ast::ComparisonValue = {
    <value:"integer"> => ast::ComparisonValue::Integer(value),
    <value:"float"> => ast::ComparisonValue::Float(value),
}

EqualityExpression: ast::Node = {
    <left:"identifier"> "=" <right:PrimitiveLiteral> => {
        ast::Node::Value(ast::Predicate {
            attribute: left.to_string(),
            kind: ast::PredicateKind::Equality(ast::EqualityOperator::Equal, right)
        })
    },
    <left:"identifier"> "<>" <right:PrimitiveLiteral> => {
        ast::Node::Value(ast::Predicate {
            attribute: left.to_string(),
            kind: ast::PredicateKind::Equality(ast::EqualityOperator::NotEqual, right)
        })
    },
    <left:PrimitiveLiteral> "=" <right:"identifier"> => {
        ast::Node::Value(ast::Predicate {
            attribute: right.to_string(),
            kind: ast::PredicateKind::Equality(ast::EqualityOperator::Equal, left)
        })
    },
    <left:PrimitiveLiteral> "<>" <right:"identifier"> => {
        ast::Node::Value(ast::Predicate {
            attribute: right.to_string(),
            kind: ast::PredicateKind::Equality(ast::EqualityOperator::NotEqual, left)
        })
    }
}

PrimitiveLiteral: ast::PrimitiveLiteral = {
    <value:"integer"> => ast::PrimitiveLiteral::Integer(value),
    <value:"float"> => ast::PrimitiveLiteral::Float(value),
    <value:"string"> => ast::PrimitiveLiteral::String(value.to_string()),
}

NullExpression: ast::Node = {
    <left:"identifier"> "is_null" => {
        ast::Node::Value(ast::Predicate {
            attribute: left.to_string(),
            kind: ast::PredicateKind::Null(ast::NullOperator::IsNull)
        })
    },
    <left:"identifier"> "is_not_null" => {
        ast::Node::Value(ast::Predicate {
            attribute: left.to_string(),
            kind: ast::PredicateKind::Null(ast::NullOperator::IsNotNull)
        })
    },
    <left:"identifier"> "is_empty" => {
        ast::Node::Value(ast::Predicate {
            attribute: left.to_string(),
            kind: ast::PredicateKind::Null(ast::NullOperator::IsEmpty)
        })
    }
}

ListExpression: ast::Node = {
    <left:"identifier"> "one_of" <list:ListLiteral> => {
        ast::Node::Value(ast::Predicate {
            attribute: left.to_string(),
            kind: ast::PredicateKind::List(ast::ListOperator::OneOf, list)
        })
    },
    <left:"identifier"> "all_of" <list:ListLiteral> => {
        ast::Node::Value(ast::Predicate {
            attribute: left.to_string(),
            kind: ast::PredicateKind::List(ast::ListOperator::AllOf, list)
        })
    },
    <left:"identifier"> "none_of" <list:ListLiteral> => {
        ast::Node::Value(ast::Predicate {
            attribute: left.to_string(),
            kind: ast::PredicateKind::List(ast::ListOperator::NoneOf, list)
        })
    }
}

SetExpression: ast::Node = {
    <left:"identifier"> "in" <list:ListLiteral> => {
        ast::Node::Value(ast::Predicate {
            attribute: left.to_string(),
            kind: ast::PredicateKind::Set(ast::SetOperator::In, list)
        })
    },
    <left:"identifier"> "not_in" <list:ListLiteral> => {
        ast::Node::Value(ast::Predicate {
            attribute: left.to_string(),
            kind: ast::PredicateKind::Set(ast::SetOperator::NotIn, list)
        })
    },
}

ListLiteral: ast::ListLiteral = {
    <values:List<"integer">> => ast::ListLiteral::IntegerList(values),
    <values:List<"string">> => ast::ListLiteral::StringList(
        values.iter().map(|value| value.to_string()).collect()
    )

}

List<T>: Vec<T> = {
    "(" <values:Comma<T>> ")" => values,
}

Comma<T>: Vec<T> = {
    <value:T> => {
        vec![value]
    },
    <mut values:(<T> ",")+> <entry:T> => {
        values.push(entry);
        values
    }
}

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token<'input> {
        "(" => Token::LeftParenthesis,
        ")" => Token::RightParenthesis,
        "," => Token::Comma,
        "<" => Token::LessThan,
        "<=" => Token::LessThanEqual,
        ">" => Token::GreaterThan,
        ">=" => Token::GreaterThanEqual,
        "not" => Token::Not,
        "=" => Token::Equal,
        "<>" => Token::NotEqual,
        "in" => Token::In,
        "not_in" => Token::NotIn,
        "one_of" => Token::OneOf,
        "none_of" => Token::NoneOf,
        "all_of" => Token::AllOf,
        "is_null" => Token::IsNull,
        "is_not_null" => Token::IsNotNull,
        "is_empty" => Token::IsEmpty,
        "and" => Token::And,
        "or" => Token::Or,
        "integer" => Token::IntegerLiteral(<i64>),
        "string" => Token::StringLiteral(<&'input str>),
        "float" => Token::FloatLiteral(<Decimal>),
        "boolean" => Token::BooleanLiteral(<bool>),
        "identifier" => Token::Identifier(<&'input str>)
    }
}
